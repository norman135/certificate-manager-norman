//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import Certificate, {
	CertificateType,
	TableCertificate,
	UpdateCretificate,
} from '../models/certificate.model';
import Supplier from '../models/supplier.model';
import User from '../models/user.model';

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class CertificatesClient {
	private http: {
		fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
	};
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
		undefined;

	constructor(
		baseUrl?: string,
		http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
	) {
		this.http = http ? http : (window as any);
		this.baseUrl = baseUrl ?? 'http://localhost:5062';
	}

	/**
	 * @param name (optional)
	 * @param firstName (optional)
	 * @param userId (optional)
	 * @param department (optional)
	 * @param plant (optional)
	 * @return Success
	 */
	users(
		name: string | undefined,
		firstName: string | undefined,
		userId: string | undefined,
		department: string | undefined,
		plant: string | undefined,
	): Promise<User[] | null> {
		let url_ = this.baseUrl + '/users?';
		if (name === null) throw new Error("The parameter 'name' cannot be null.");
		else if (name !== undefined)
			url_ += 'Name=' + encodeURIComponent('' + name) + '&';
		if (firstName === null)
			throw new Error("The parameter 'firstName' cannot be null.");
		else if (firstName !== undefined)
			url_ += 'FirstName=' + encodeURIComponent('' + firstName) + '&';
		if (userId === null)
			throw new Error("The parameter 'userId' cannot be null.");
		else if (userId !== undefined)
			url_ += 'UserId=' + encodeURIComponent('' + userId) + '&';
		if (department === null)
			throw new Error("The parameter 'department' cannot be null.");
		else if (department !== undefined)
			url_ += 'Department=' + encodeURIComponent('' + department) + '&';
		if (plant === null)
			throw new Error("The parameter 'plant' cannot be null.");
		else if (plant !== undefined)
			url_ += 'Plant=' + encodeURIComponent('' + plant) + '&';
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'GET',
			headers: {},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processUsers(_response);
		});
	}

	protected processUsers(response: Response): Promise<User[] | null> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				return JSON.parse(_responseText);
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<null>(null as any);
	}

	/**
	 * @param index (optional)
	 * @param name (optional)
	 * @param city (optional)
	 * @return Success
	 */
	suppliers(
		index: number | undefined,
		name: string | undefined,
		city: string | undefined,
	): Promise<Supplier[] | null> {
		let url_ = this.baseUrl + '/suppliers?';
		if (index === null)
			throw new Error("The parameter 'index' cannot be null.");
		else if (index !== undefined)
			url_ += 'Index=' + encodeURIComponent('' + index) + '&';
		if (name === null) throw new Error("The parameter 'name' cannot be null.");
		else if (name !== undefined)
			url_ += 'Name=' + encodeURIComponent('' + name) + '&';
		if (city === null) throw new Error("The parameter 'city' cannot be null.");
		else if (city !== undefined)
			url_ += 'City=' + encodeURIComponent('' + city) + '&';
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'GET',
			headers: {},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processSuppliers(_response);
		});
	}

	protected processSuppliers(response: Response): Promise<Supplier[] | null> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				return JSON.parse(_responseText);
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<null>(null as any);
	}

	/**
	 * @return Success
	 */
	types(): Promise<CertificateType[] | null> {
		let url_ = this.baseUrl + '/certificates/types';
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'GET',
			headers: {},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processTypes(_response);
		});
	}

	protected processTypes(
		response: Response,
	): Promise<CertificateType[] | null> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				return JSON.parse(_responseText);
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<null>(null as any);
	}

	/**
	 * @return Success
	 */
	certificatesGET(): Promise<TableCertificate[] | null> {
		let url_ = this.baseUrl + '/certificates';
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'GET',
			headers: {},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCertificatesGET(_response);
		});
	}

	protected processCertificatesGET(
		response: Response,
	): Promise<TableCertificate[] | null> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				return JSON.parse(_responseText);
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<null>(null as any);
	}

	/**
	 * @param body (optional)
	 * @return Success
	 */
	certificatesPOST(
		body: CreateCertificateDTO | undefined,
	): Promise<boolean | null> {
		let url_ = this.baseUrl + '/certificates';
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(body);

		let options_: RequestInit = {
			body: content_,
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCertificatesPOST(_response);
		});
	}

	protected processCertificatesPOST(
		response: Response,
	): Promise<boolean | null> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 201) {
			return response.text().then((_responseText) => {
				return true;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<null>(null as any);
	}

	/**
	 * @return Success
	 */
	certificatesGET2(handle: string): Promise<Certificate | null> {
		let url_ = this.baseUrl + '/certificates/{handle}';
		if (handle === undefined || handle === null)
			throw new Error("The parameter 'handle' must be defined.");
		url_ = url_.replace('{handle}', encodeURIComponent('' + handle));
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'GET',
			headers: {},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCertificatesGET2(_response);
		});
	}

	protected processCertificatesGET2(
		response: Response,
	): Promise<Certificate | null> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				return JSON.parse(_responseText);
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<null>(null as any);
	}

	/**
	 * @param body (optional)
	 * @return Success
	 */
	certificatesPUT(
		handle: string,
		body: UpdateCretificate | undefined,
	): Promise<boolean | null> {
		let url_ = this.baseUrl + '/certificates/{handle}';
		if (handle === undefined || handle === null)
			throw new Error("The parameter 'handle' must be defined.");
		url_ = url_.replace('{handle}', encodeURIComponent('' + handle));
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(body);

		let options_: RequestInit = {
			body: content_,
			method: 'PUT',
			headers: {
				'Content-Type': 'application/json',
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCertificatesPUT(_response);
		});
	}

	protected processCertificatesPUT(
		response: Response,
	): Promise<boolean | null> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				return true;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<null>(null as any);
	}

	/**
	 * @return Success
	 */
	certificatesDELETE(handle: string): Promise<boolean | null> {
		let url_ = this.baseUrl + '/certificates/{handle}';
		if (handle === undefined || handle === null)
			throw new Error("The parameter 'handle' must be defined.");
		url_ = url_.replace('{handle}', encodeURIComponent('' + handle));
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'DELETE',
			headers: {},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCertificatesDELETE(_response);
		});
	}

	protected processCertificatesDELETE(
		response: Response,
	): Promise<boolean | null> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 204) {
			return response.text().then((_responseText) => {
				return true;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<null>(null as any);
	}

	/**
	 * @param body (optional)
	 * @return Success
	 */
	comments(
		handle: string,
		body: CreateCommentDTO | undefined,
	): Promise<boolean | null> {
		let url_ = this.baseUrl + '/certificates/{handle}/comments';
		if (handle === undefined || handle === null)
			throw new Error("The parameter 'handle' must be defined.");
		url_ = url_.replace('{handle}', encodeURIComponent('' + handle));
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(body);

		let options_: RequestInit = {
			body: content_,
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processComments(_response);
		});
	}

	protected processComments(response: Response): Promise<boolean | null> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 201) {
			return response.text().then((_responseText) => {
				return true;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<null>(null as any);
	}
}

export class CreateCertificateDTO implements ICreateCertificateDTO {
	supplierHandle?: string | undefined;
	certificateTypeHandle?: string | undefined;
	validFrom?: string | undefined;
	validTo?: string | undefined;
	document?: string | undefined;

	constructor(data?: ICreateCertificateDTO) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.supplierHandle = _data['supplierHandle'];
			this.certificateTypeHandle = _data['certificateTypeHandle'];
			this.validFrom = _data['validFrom'];
			this.validTo = _data['validTo'];
			this.document = _data['document'];
		}
	}

	static fromJS(data: any): CreateCertificateDTO {
		data = typeof data === 'object' ? data : {};
		let result = new CreateCertificateDTO();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data['supplierHandle'] = this.supplierHandle;
		data['certificateTypeHandle'] = this.certificateTypeHandle;
		data['validFrom'] = this.validFrom;
		data['validTo'] = this.validTo;
		data['document'] = this.document;
		return data;
	}
}

export interface ICreateCertificateDTO {
	supplierHandle?: string | undefined;
	certificateTypeHandle?: string | undefined;
	validFrom?: string | undefined;
	validTo?: string | undefined;
	document?: string | undefined;
}

export class CreateCommentDTO implements ICreateCommentDTO {
	userHandle?: string | undefined;
	commentText?: string | undefined;

	constructor(data?: ICreateCommentDTO) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.userHandle = _data['userHandle'];
			this.commentText = _data['commentText'];
		}
	}

	static fromJS(data: any): CreateCommentDTO {
		data = typeof data === 'object' ? data : {};
		let result = new CreateCommentDTO();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data['userHandle'] = this.userHandle;
		data['commentText'] = this.commentText;
		return data;
	}
}

export interface ICreateCommentDTO {
	userHandle?: string | undefined;
	commentText?: string | undefined;
}

export class UpdateCertificateDTO implements IUpdateCertificateDTO {
	supplierHandle?: string | undefined;
	certificateTypeHandle?: string | undefined;
	validFrom?: string | undefined;
	validTo?: string | undefined;
	document?: string | undefined;
	participants?: UserDTO[] | undefined;

	constructor(data?: IUpdateCertificateDTO) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.supplierHandle = _data['supplierHandle'];
			this.certificateTypeHandle = _data['certificateTypeHandle'];
			this.validFrom = _data['validFrom'];
			this.validTo = _data['validTo'];
			this.document = _data['document'];
			if (Array.isArray(_data['participants'])) {
				this.participants = [] as any;
				for (let item of _data['participants'])
					this.participants!.push(UserDTO.fromJS(item));
			}
		}
	}

	static fromJS(data: any): UpdateCertificateDTO {
		data = typeof data === 'object' ? data : {};
		let result = new UpdateCertificateDTO();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data['supplierHandle'] = this.supplierHandle;
		data['certificateTypeHandle'] = this.certificateTypeHandle;
		data['validFrom'] = this.validFrom;
		data['validTo'] = this.validTo;
		data['document'] = this.document;
		if (Array.isArray(this.participants)) {
			data['participants'] = [];
			for (let item of this.participants)
				data['participants'].push(item.toJSON());
		}
		return data;
	}
}

export interface IUpdateCertificateDTO {
	supplierHandle?: string | undefined;
	certificateTypeHandle?: string | undefined;
	validFrom?: string | undefined;
	validTo?: string | undefined;
	document?: string | undefined;
	participants?: UserDTO[] | undefined;
}

export class UserDTO implements IUserDTO {
	handle?: string | undefined;
	name?: string | undefined;
	firstName?: string | undefined;
	email?: string | undefined;
	userId?: string | undefined;
	department?: string | undefined;
	plant?: string | undefined;

	constructor(data?: IUserDTO) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.handle = _data['handle'];
			this.name = _data['name'];
			this.firstName = _data['firstName'];
			this.email = _data['email'];
			this.userId = _data['userId'];
			this.department = _data['department'];
			this.plant = _data['plant'];
		}
	}

	static fromJS(data: any): UserDTO {
		data = typeof data === 'object' ? data : {};
		let result = new UserDTO();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data['handle'] = this.handle;
		data['name'] = this.name;
		data['firstName'] = this.firstName;
		data['email'] = this.email;
		data['userId'] = this.userId;
		data['department'] = this.department;
		data['plant'] = this.plant;
		return data;
	}
}

export interface IUserDTO {
	handle?: string | undefined;
	name?: string | undefined;
	firstName?: string | undefined;
	email?: string | undefined;
	userId?: string | undefined;
	department?: string | undefined;
	plant?: string | undefined;
}

export class ApiException extends Error {
	message: string;
	status: number;
	response: string;
	headers: { [key: string]: any };
	result: any;

	constructor(
		message: string,
		status: number,
		response: string,
		headers: { [key: string]: any },
		result: any,
	) {
		super();

		this.message = message;
		this.status = status;
		this.response = response;
		this.headers = headers;
		this.result = result;
	}

	protected isApiException = true;

	static isApiException(obj: any): obj is ApiException {
		return obj.isApiException === true;
	}
}

function throwException(
	message: string,
	status: number,
	response: string,
	headers: { [key: string]: any },
	result?: any,
): any {
	if (result !== null && result !== undefined) throw result;
	else throw new ApiException(message, status, response, headers, null);
}
